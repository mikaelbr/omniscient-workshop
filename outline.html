<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle

# Functional UI, Composable Components and Unidirectional immutable data

---

# The Beginning
## Static HTML, No JS

First there was pure, perfect static model: Just rendering in declarative way. Things were easy to understand just by taking a glance. But there were no inputs. Just static texts as values and attributes.

---

# The Need for Dynamic Views
## Using JS to change the DOM

Need for dynamic changes without server change. In time we got Mootools and jQuery. Now we had ways to traverse, update and manipulate the DOM with ease. Didn’t have much models or any good way in the code to represent what state we have in the DOM

---

# The Need for Structural Views
## More Responsibility to JS

As time went and javascript got more and more popular and as we moved to thicker clients and more logic in the browser, we got things as Backbone. We had models and some javascript views, but still driven by massive blob of a side-effect that is the stateful DOM. It’s not necessarily easy to predict the current state of the DOM, even if we have some representation.

---

# The De-tour Through Increased Power of Models
## Hard-linking Models and DOM

We also got things like Knockout, and later Angular, Ember and such. We could bind a model to a view. The problem is, you very rarely have a model which you can bind directly to a view, so you can have view models, or other representations, but then you’d have to either listen for propagating changes and having weird hacks for propagating changes in the object models doing dirty bit checking or some other polling. And you still have this built up state that’s not too easily reproducible or predictable. We still don’t have the same static mental model as in the pure HTML days


---

# Real Power of Programming
## Moving Views All The Way To JS

The next iteration for views is taking the back to a static model and predictable views. Instead of taking the step of moving more JS into the markup, we do the opposite and move views entirely into a representation in a declarative manner of writing composable views, just as with HTML - but with extended functionality. Instead of having a powerful programming language in a less powerful representation language, we move the representation to the programming language.

---

# Building Representation of Views in JS
## Advantages Of Using React and it's Virtual DOM

---

# Static Mental Model Just Like Good Old HTML

Built for changes over time, and between each change it essentially does a refresh, but has a internal representation of the DOM which it's diffed gainst and the actual changes only occurs when the new generated virtual DOM diverges from the old.

---

```js
React.render(
  React.DOM.h1({}, 'Hello, world!'),
  document.body
);
```

Many, or most, of you might have seen React before, but here is an example, in plain old JS.

---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, world!');
  }
});

// Need to create element from class
React.render(React.createElement(Hello), document.body);
```

Or we can make a component of it, which we can re-use in different settings and compose.

---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, ' + this.props.user.name + '!');
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(React.createElement(Hello, myProps), document.body);
```

We can also pass properties to the components. Much like attributes and children of regular HTML, but instead of being restricted to a protocol of only strings, we can pass objects and more advanced constructs.

---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, ' + this.props.user.name + '!');
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(React.createElement(Hello, myProps), document.body);

// Render again:
myProps.user.name = 'Scott Lang';
React.render(React.createElement(Hello, myProps), document.body);
```

This will update the view, diff against the virtual dom and render the change. We see here a really static mental model. We can see that we, depending on the input, will print "Hello, SOME NAME!".

---

# Syntactic Sugar: JSX

```js
React.render(
  <h1>Hello, world!</h1>,
  document.body);

//=> Translated to
React.render(
  React.createElement('h1', {}, 'Hello, world!'),
  document.body);
```


In React 0.12.0, they changed from rendering components into rendering Elements based on classes. This to move towards ES6 "Classes". This means in vanilla React it can be somewhat verbose syntax for non-JSX, allthough it is still possible. We'll see later in this workshop how we can make working with vanilla JS better.

JSX is a transpile-to-JS language, with a very small transpilation distance.

---

```jsx
var Hello = React.createClass({
  render: function () {
    return <h1>Hello, {this.props.user.name}!</h1>;
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(<Hello user={myProps.user) />, document.body);
```

Previous example with JSX.

---

##  Assignments: Creating Components

Test out the playground: http://omniscientjs.github.io/workshop

Do following assignments
- Part 1: Making Basic Components
- Part 1: Passing Properties

---

# composable components

## Assignments
 - Composing components (children)

---

# virtual DOM

## Assignments

 - Render twice to update view using setTimeout.
 - Render a clock using setInterval
 - Advanced: Some advanced task

---

???

Setup:
 - react component state change causes re-render
 - state gets out of hand

 åpner for mange nye muligheter
 kan forstatt bajse på leggen
 ta det ett skritt lenger

 for å kunne gjenskal den mentale modellen som vi hadde fra html
 låne konsepter fra funksjonell programmering
 og det gjøre resonnering om grensesnittene våre enklere.
 less error prone system

---

# functional paradigm

---

## mental model

Strive for principles of functional programming?

- easier mental model
- easier to write
- modular programs
- decompose problems into parts

???

- in terms of functional views, as a result, when you find a bug, just dig into the component and _know_ that this is where all 

---

## referential transparency

"An expresssion is referentially transparent if it can be replaced with its value without changing the behavior of the program."

Given the same input, the program has the same effects and outputs

`42 + 42 => 84`

```
var global = 42;
...
global + 42 => ???
```

???

- Side effect free.
- predictable output
- easier to test
- Property of parts of computer programs.
- For programs to be interesting we actually need state and side effects!
- Common examples include the dom, ajax communcation, logging etc.

---

## higher order functions

The glue.

Primary building block of functional programming.

- Functions as values
- Functions can take functions as arguments
- Functions can return functions

???

composability

---

TODO én playground

```
var adder = function (add) {
  return function (x) {
    return add + x;
  };
};
var add2 = adder(2);
add2(4); // 6
```
[run](http://omniscientjs.github.io/playground/#var%20adder%20%3D%20function%20(add)%20%7B%0A%20%20return%20function%20(x)%20%7B%0A%20%20%20%20return%20add%20%2B%20x%3B%0A%20%20%7D%3B%0A%7D%3B%0Avar%20add2%20%3D%20adder(2)%3B%0Ait('adds%202'%2C%20()%20%3D%3E%20add2(4).should.equal(6))%3B)

---

```
var list = [1, 2, 3];
var square = function (n) {
  return n * n;
};
it('squares numbers', function () {
  list.map(square).should.eql([1, 4, 9])
});
```
[run](http://omniscientjs.github.io/playground/#var%20list%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Avar%20square%20%3D%20function%20(n)%20%7B%0A%20%20return%20n%20*%20n%3B%0A%7D%3B%0Ait('squares%20numbers'%2C%20function%20()%20%7B%0A%20%20list.map(square).should.eql(%5B1%2C%204%2C%209%5D)%0A%7D)%3B)

---

```
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var isFizzOrBuzz = function (n) {
  /*solution return n % 5 == 0 || n % 3 == 0;*/
};
it('keeps fizzbuzz numbers', function () {
  numbers.filter(isFizzOrBuzz).should.eql([3, 5, 6, 9, 10])
});
```
[run](http://omniscientjs.github.io/playground/#var%20numbers%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%2C%206%2C%207%2C%208%2C%209%2C%2010%5D%3B%0Avar%20isFizzOrBuzz%20%3D%20function%20(n)%20%7B%0A%20%20return%20n%20%25%205%20%3D%3D%200%20%7C%7C%20n%20%25%203%20%3D%3D%200%3B%0A%7D%3B%0Ait('keeps%20fizzbuzz%20numbers'%2C%20function%20()%20%7B%0A%20%20numbers.filter(isFizzOrBuzz).should.eql(%5B3%2C%205%2C%206%2C%209%2C%2010%5D)%0A%7D)%3B)

---

```
var numbers = [1, 2, 3, 4, 5];
var multiply = function (acc, n) {
  return acc * n;
}
it('multiplies numbers', function () {
  numbers.reduce(multiply, 1).should.equal(120);
});
```
[run](http://omniscientjs.github.io/playground/#var%20numbers%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0Avar%20multiply%20%3D%20function%20(acc%2C%20n)%20%7B%0A%20%20return%20acc%20*%20n%3B%0A%7D%0Ait('multiplies%20numbers'%2C%20function%20()%20%7B%0A%20%20numbers.reduce(multiply%2C%201).should.equal(120)%3B%0A%7D)%3B)

---

```
var episodes = [
  { name: "Cartman Gets an Anal Probe" },
  { name: "Weight Gain 4000" },
  { name: "Volcano" },
  { name: "Big Gay Al's Big Gay Boat Ride" },
  { name: "An Elephant Makes Love to a Pig" },
  { name: "Death" },
  { name: "Pinkeye" },
  { name: "Starvin' Marvin" },
  { name: "Mr. Hankey, the Christmas Poo" },
  { name: "Damien" },
  { name: "Tom's Rhinoplasty" },
  { name: "Mecha-Streisand" },
  { name: "Cartman's Mom Is a Dirty Slut" }];

function asName (obj) {
  return obj.name;
}

it('maps episodes => name', function () {
  episodes.map(asName)[0].should.equal("Cartman Gets an Anal Probe");
  episodes.map(asName)[1].should.equal("Weight Gain 4000");
});
```
[run](http://omniscientjs.github.io/playground/#var%20episodes%20%3D%20%5B%0A%20%20%7B%20name%3A%20%22Cartman%20Gets%20an%20Anal%20Probe%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Weight%20Gain%204000%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Volcano%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Big%20Gay%20Al's%20Big%20Gay%20Boat%20Ride%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22An%20Elephant%20Makes%20Love%20to%20a%20Pig%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Death%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Pinkeye%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Starvin'%20Marvin%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Mr.%20Hankey%2C%20the%20Christmas%20Poo%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Damien%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Tom's%20Rhinoplasty%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Mecha-Streisand%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Cartman's%20Mom%20Is%20a%20Dirty%20Slut%22%20%7D%5D%3B%0A%0Afunction%20asName%20(obj)%20%7B%0A%20%20return%20obj.name%3B%0A%7D%0A%0Ait('maps%20episodes%20%3D%3E%20name'%2C%20function%20()%20%7B%0A%20%20episodes.map(asName)%5B0%5D.should.equal(%22Cartman%20Gets%20an%20Anal%20Probe%22)%3B%0A%20%20episodes.map(asName)%5B1%5D.should.equal(%22Weight%20Gain%204000%22)%3B%0A%7D)%3B)


alt dette er eksempler på higher order functions
sender funksjoner som blir brukt for å gjøre operasjoner
alt er lister
det programmering handelr om er endring av verdier over tid
transformering av data fra en representasjon til en annen

hvorfor pure? og immutability? andre skal ikke kunne nedre på noe som du har som utgangspunkt

oppgave

 - rekursivitet?

---

# immutability

Note that while operations like map, filter, reduce etc. return new lists,
the content of these lists may well be the same object references you
started out with.

???

- but not everything is immutable in js as of today

---

- Object.freeze()

???

- not everything is immutable, easy to loose track of modifications
- what can we do about it?
- makes it immutable, fozen
- not efficient
- cant update it without copying all values to a new object

- how can we copy it?
- can we copy everything all the time?
- the two are almost exaclty the same - doesnt this use twice the space?

---

clojure

```
(def user {:firstname "torgeir"})
(def modified-user (assoc user :lastname "thoresen"))
(= user modified-user) // false
```

???

- some languages have immutable data by default
- ta vare på det du output av det du gjør
- ser aldri en void funksjon i funksjonell programmering

---

Some thing are immutable, in most languages!

```
var name = 'bob';

it('returns new strings', function () {
  var names = name + ' & alice';

  names.should.equal('bob & alice');
  name.should.equal('bob');
});
```

- strings
- primitive datatypes, ints

javascript litt confused når det kommer til immutability
- concat, slår sammen to lister, er immutable => får alltid en ny liste uten å røre den gamle
- push, muterende => ingen grunn til det egentlig?

---

# js alternatives

- ki
- mori
- clojurescript

???

- there are alternatives for js
- no one is javascript idiomatic
- until..

---

## immutable.js

- facebook
- immutable data strcutures for js
- idiomatic javascript api (behandler objekter slik du behandler javascript objekter ellers, samme operasjoner)

???

- smart, nerdy guy at facebook, lee byron
- immutable structures for js
- because data is immutable, data never changes, data can be shared

- sub trees in the larger structure can share information
- persistent data structures
- share structures

bilde av tree, når data endrer seg

---

### assignments

TODO én playground

```
var List = Immutable.List;

var initial = List([1, 2]);
var modified = initial.push(3);

initial // 1, 2
modified // 1, 2, 3

```

---

```
var initial = List.of(2, 4, 6, 8);
var modified = initial.remove(2);
modified // 2, 4, 8
```

---

```
List.of(10, 20, 30, 40, 50).indexOf(30); // 2
```

---

```
var Map = Immutable.Map;

var map = Map({ "key": "value" });
map.get('key'); // value
```

---

```
var initial = Map().set(List.of(1), 'list-of-one');
initial.get(List.of(1)); // list-of-one
```

---

```
var first = Map({
  firstname: 'torgeir'
});

var last = Map({
  lastname: 'thoresen'
});

var merged = first.merge(last);

merged.toJS() // { firstname: 'torgeir', lastname: 'thoresen' }
```

---

```
var data = Immutable.fromJS({ some: { structure: [1, 2, 3] } });

data.getIn(['some', 'structure']) // Immutable.List([1, 2, 3])

var updated = data.setIn(['some', 'structure', '0'], 42);

updated.toJS(); // { some: { structure: [42, 2, 3 ] } }
data.toJS(); // { some: { structure: [1, 2, 3 ] } }
```

gotcha: hva om man setter inn enn VANLIG liste, og ikke en immutable én
---

debugging

```
updated.inspect(); // "Map { some: Map { structure: List [ 42, 2, 3 ] } }"
```

---

### assignments

- range - create a list with 100 items
- map - map over the numbers to double every number
- filter - filter out every odd numbers
- reduce - reduce the numbers to find their sum

- advanced: implement curry() in js

todo vise frem curry-oppgaven?

---

## cursors

- concept is similar to functional lenses
- pointers into a data structure
- pass a reference on to others
- cursor knows its path in the structure
- get a value out of it,
- or operate on the value

separation of concerns
isolere handlinger mot forskjellige deler av en strukturer i en applikasjon
much like a view

in terms of components; useful with react components
a component "owns" a piece of state inside a larger structure

yes we can pass object references as props
what happens if one component mutates the value of a reference
another component might have its props changed, tighlty couples the two components, horizontal coupling
egentlig en bieffekt - et uhell
slippery slope
ikke lenger purity, ikke lenger god testbarhet, ikke lenger fordelere med concurrency

React 13 will freeze props. Can pass immutable props? yes, but you cant update them.

siden cursors bare passer referanser ned og ikke selve dataen
kan vi faktisk bytte ut den delen av treet cursoren peker til, i det man gjør en gjør en operasjon på en cursor
(som også er immutable)

én struktur som ligger utenfor komponentene
ingen komponenter refererer direkte til strukturen
ingen kommunikasjon horizontalt, men alle komponenter
får sine data fra toppen, som input - som én pure funksjon!

???

### assignments

- vise hvordan man lager cursor
- vise hvordan man update'er cursor
- vise immutabilityen til en cursor
- vise frem at en handler kalles i det man endrer på en cursor

- advanced: lag funksjon som når den kalles alltid returnerer den nyeste strukturen

---

## Immstruct

http://omniscientjs.github.io/playground/#console.clear()%3B%0A%0Acomponent%20%3D%20component.withDefaults(%7Bjsx%3Atrue%7D)%0Avar%20data%20%3D%20immstruct(%7B%0A%20%20l1%3A%20%7B%0A%20%20%20%20l2%3A%20%7B%0A%20%20%20%20%20%20l3%3A%20%7B%0A%20%20%20%20%20%20%20%20l4%3A%20%22initial%22%2C%0A%20%20%20%20%20%20%20%20l44%3A%20%7B%20l5%3A%20true%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%2C%0A%20%20%20%20l22%3A%20%7B%20l3%3A%20true%20%7D%0A%20%20%7D%0A%7D)%3B%0A%0Avar%20newData%20%3D%20data.cursor().updateIn(%0A%20%20%5B'l1'%2C%20'l2'%2C%20'l3'%2C%20'l4'%5D%2C%0A%20%20_%20%3D%3E%20'yes')%3B%0A%0Adata.cursor(%5B'l1'%2C%20'l2'%2C%20'l3'%2C%20'l44'%5D)%0A%20%20.deref()%0A%20%20.should.equal(%0A%20%20%20%20newData.cursor(%5B'l1'%2C%20'l2'%2C%20'l3'%2C%20'l44'%5D)%0A%20%20%20%20%20%20.deref())%0A%0Adata.cursor(%5B'l1'%2C%20'l22'%5D)%0A%20%20.deref()%0A%20%20.should.equal(%0A%20%20%20%20newData.cursor(%5B'l1'%2C%20'l22'%5D)%0A%20%20%20%20%20%20.deref())%0A%0Aconsole.log(data.cursor(%5B'l1'%2C%20'l22'%5D).deref())%0A

cursors can update a piece in a structure, but returns the new structure

abstraction to update the structure when a piece changes

without affecting the other parts of the tree

listen for changes - swap

super easy to re-render on swap

- show updating a cursor and logging on the swap event, to show whats updated

kan gjøre endring
gjøre noe når strukturen endrer seg
refresh av data
passer ikke det veldig bra med react - refhresher viewet når man rendrer på nytt?
kan rendre hele greia på nytt

???

react is not a silver bullet
atom had to move away from it
to fragmented painting, to much gc on changes

- SHOw tszackala, bytt det med black panter - render on swap, and change the cursor

---

### assignments

```
var Counter  = React.createClass({

  render: function () {

    var counter = this.props.counter;
    var inc = function (e) {
      counter.update(function (v) {
        return v + 1;
      });
    }

    return <button onClick={inc}>{counter.deref()}</button>;
  }
});


var data = immstruct({ counter: 0 });

var render = function () {
  React.render(<Counter counter={data.cursor('counter')} />, el);
};

data.on('swap', function () {
  render();
});

render();
```

- implement a clock with its own immstruct data structure

- Is that smart? Rerender all the things??
- React is clever, and super fast
- But can we do even better!

---

# React sin shouldComponentUpdate

- A react performance optimization
- Override the function to tell react when a rerender is not nescessary
- fortelle en komopnent når den trenger å re-rendre!
- kan sendes inn som en mixin til en komponent

vise hvordan mixins fungerer
vise signaturen til should component update
vise hvordan den kan brukes

- is not should component update a perfect fit for immutable datastructures?
- instead of deep equaling all arguments to check if theyve changed, and we need to re-render
- vise hvordan man kan simply check references

## assignments

- create a component that only renders the first time! and never again on new React.render() calls

- write your own mixin that only rerenders when your component is passed odd numbers

```
var OnlyShowOddNumbers = {
  shouldComponentUpdate: function (nextProps) {
    return nextProps.number % 2 !== 0;
  }
};

var OddNumbers = React.createClass({
  mixins: [OnlyShowOddNumbers],
  render: function () {
    return <span>{this.props.number}</span>;
  }
});

function render (n) {
  React.render(OddNumbers({ number: n }), el);
}

var i = 0;
setInterval(function () {
  render(i++)
}, 1000);
```

assignment: should component that handles immutable structures

## assignments

fint for små komponenter
hva når datastrukturer blir store
må alle komponenetene vite om hele strukturen
kan sende referansene til hvor du finner data - cursors

immutable data har vært vanskelig i js, om gjør det
har kommet flere i det siste, flux gjør det, men mye mer overhead i arkitektur

vi syns det mangler for javascript

# omniscient

react med omniscient should component update

vise omniscient syntaktisk sukker
purity, ref. transparency, rettningslinjer til hvordan du kan lage funksjonelle grensesnitt
lage komponenter som følge disse prinsippene
rene på samme måte som funksjonene er rene
ref. transparent på samme måte som funksjonene er ref. transparent

samme gagn for komponenter som man har av funksjonell kode
opnådd målet med workshoppoen

kan oppnå akkurat det samme med ren react og immutable js
ender med å implementere noe som ligner på immstruct og omniscient
mindre battle tested løsning

kan bruke state - i blant trenger man det - selvfølgelig er det mulig

## assignments
- react with omniscients should component update

endrer fokusområdet til content first
alt en komponent trenger å være er innhold
composability av innhold
render funksjon som er lett å ressonnere over
tar inn argument og jobber bare med det - pure
referencial transparency
higher order components - komponenter tar inn komponenter, returnerer andre komponenter - compsable

isteden for funksjonell programmering på funksjonsnivå
har funksjonell programmering på komponentnivå

## assignments
- pass props
- pass cursors
- effective re-render
- render loop

av og til trenger man ekstra funksjonalitet
lagt opp til at den er enkel på å dele via mixins (traits)
legge funksjonene utenfor komponentene

## assignments

- legge til én mixin
- legge til flere mixins
- legge til react life cycle mixins (alle er garantert til å bli utført, hvis det finnes flere)

Assignments:
 - Creating updatable omniscient components (render loop)

Extras:
 - Remote data?

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>

