<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle

# Functional UI, Composable Components and Unidirectional immutable data

---

# The Beginning
## Static HTML, No JS

???

First there was pure, perfect static model: Just rendering in declarative way. Things were easy to understand just by taking a glance. But there were no inputs. Just static texts as values and attributes.

---

# The Need for Dynamic Views
## Using JS to change the DOM

???

Need for dynamic changes without server change. In time we got Mootools and jQuery. Now we had ways to traverse, update and manipulate the DOM with ease. Didn’t have much models or any good way in the code to represent what state we have in the DOM

---

# The Need for Structural Views
## More Responsibility to JS

???

As time went and javascript got more and more popular and as we moved to thicker clients and more logic in the browser, we got things as Backbone. We had models and some javascript views, but still driven by massive blob of a side-effect that is the stateful DOM. It’s not necessarily easy to predict the current state of the DOM, even if we have some representation.

---

# The De-tour Through Increased Power of Models
## Hard-linking Models and DOM

???

We also got things like Knockout, and later Angular, Ember and such. We could bind a model to a view. The problem is, you very rarely have a model which you can bind directly to a view, so you can have view models, or other representations, but then you’d have to either listen for propagating changes and having weird hacks for propagating changes in the object models doing dirty bit checking or some other polling. And you still have this built up state that’s not too easily reproducible or predictable. We still don’t have the same static mental model as in the pure HTML days


---

# Real Power of Programming
## Moving Views All The Way To JS

???

The next iteration for views is taking the back to a static model and predictable views. Instead of taking the step of moving more JS into the markup, we do the opposite and move views entirely into a representation in a declarative manner of writing composable views, just as with HTML - but with extended functionality. Instead of having a powerful programming language in a less powerful representation language, we move the representation to the programming language.

---

# Building Representation of Views in JS
## Advantages Of Using React and it's Virtual DOM

---

# Static Mental Model Just Like Good Old HTML

???

Built for changes over time, and between each change it essentially does a refresh, but has a internal representation of the DOM which it's diffed gainst and the actual changes only occurs when the new generated virtual DOM diverges from the old.

---

```js
React.render(
  React.DOM.h1({}, 'Hello, world!'),
  document.body
);
```

???

Many, or most, of you might have seen React before, but here is an example, in plain old JS.

---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, world!');
  }
});

// Need to create element from class
React.render(React.createElement(Hello), document.body);
```

???

Or we can make a component of it, which we can re-use in different settings and compose.

In the latest version of React (0.13), they have transition into using ES6 classes, but you
could also use module patterns or ES3 classes.


---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, ' + this.props.user.name + '!');
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(React.createElement(Hello, myProps), document.body);
```

???

We can also pass properties to the components. Much like attributes and children of regular HTML, but instead of being restricted to a protocol of only strings, we can pass objects and more advanced constructs.

---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, ' + this.props.user.name + '!');
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(React.createElement(Hello, myProps), document.body);

// Render again:
myProps.user.name = 'Scott Lang';
React.render(React.createElement(Hello, myProps), document.body);
```

???

This will update the view, diff against the virtual dom and render the change. We see here a really static mental model. We can see that we, depending on the input, will print "Hello, SOME NAME!".

---

# Syntactic Sugar: JSX

```js
React.render(
  <h1>Hello, world!</h1>,
  document.body);

//=> Translated to
React.render(
  React.createElement('h1', {}, 'Hello, world!'),
  document.body);
```

???

In React 0.12.0, they changed from rendering components into rendering Elements based on classes. This to move towards ES6 "Classes". This means in vanilla React it can be somewhat verbose syntax for non-JSX, allthough it is still possible. We'll see later in this workshop how we can make working with vanilla JS better.

JSX is a transpile-to-JS language, with a very small transpilation distance.

---

```jsx
var Hello = React.createClass({
  render: function () {
    return <h1>Hello, {this.props.user.name}!</h1>;
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(<Hello user={myProps.user) />, document.body);
```

Previous example with JSX.

---

##  Assignments: Creating Components

Test out the playground: http://omniscientjs.github.io/workshop

Do following assignments
- Part 1: Making Basic Components
- Part 1: Passing Properties

---

# Composability Through Components

???

Just rendering a HTML document isn't much of an application, and we could just use
HTML if we weren't making a more complex application. We need to combine different
components for making larger structures.

```jsx
var Greeting = React.createClass({
  render: function () {
    return (
      <div>
        <h1>Hello, {this.props.user.name}!</h1>
        <p>Here, have some chimichangas!</p>
      </div>
    );
  }
});

var myProps = { user: { name: 'Wade Wilson' } };
React.render(<Greeting user={myProps.user) />, document.body);
```

---

```jsx
var Hello = React.createClass({
  render: function () {
    return <h1>Hello, {this.props.username}!</h1>;
  }
});

Var Greeting = React.createClass({
  render: function () {
    return (
      <div>
        <Hello username={this.props.user.name} />
        <p>You look like Spider-man!</p>
      </div>
    );
  }
});

var myProps = { user: { name: 'Wade Wilson' } };
React.render(<Greeting user={myProps.user) />, document.body);
```

---

```jsx
var Hello = React.createClass({
  render: function () {
    return <h1>Hello, {this.props.children}!</h1>;
  }
});

var Greeting = React.createClass({
  render: function () {
    return (
      <div>
        <Hello><em>{this.props.user.name}</em></Hello>
        <p>Wheres Pandapool?</p>
      </div>
    );
  }
});

var myProps = { user: { name: 'Wade Wilson' } };
React.render(<Greeting user={myProps.user} />, document.body);
```

---

# Functional Patterns for UI
## __(more info on this later)__
---

```jsx
var h1 = input => <h1>{input}</h1>;
var em = input => <em>{input}</em>;
var compose = (a, b) => (input => a(b(input)));
var italicH1 = compose(h1, em);

var Greeting = React.createClass({
  render: function () {
    return (
      <div>
        {italicH1(this.props.name)}
        <p>You got some vibranium?</p>
      </div>
    );
  }
});

React.render(<Greeting name="T'Challa" />, document.body);
```

---

Workshop Tasks: http://omniscientjs.github.io/workshop

Do following assignments
- Part 1: Composing Simple Components
- Part 1: Composing Components Through Children
- Part 1: Composing Many Children
- Part 1: Composing Through Small Functions
- Part 1: Some Advanced Task

---

# DOM is a Side-Effect
## Abstract Side-Effects to Edges of Communication Graph

???

We don't want to handle the communication to the DOM our self.
Firstly, integration tests to the DOM is a pain, it is slow
and it is a huge state which is built through different
operations which is easy to loose track off. We can avoid that
by "refreshing" the view entirly and only showing the latest
changes to the UI.


---

# Virtual DOM
## What Allows Us To Write Smart DOM Representations

???

- So the Virtual DOM, which React implements, helps us abstracting the DOM.
We don't have to handle the DOM our self. Important part however, is
that the distance between the DOM and the Virtual DOM isn't big. It's not
like Hibernate and SQL.

---

# In-memory Representation of the DOM
## Only Actually Render When Output Changes

???

- The Virtual DOM works by having a in-memory representation of the DOM
and on update / refresh it does a fast diff between the new generated virtual
DOM and the current internal DOM, and it only updates to the actual DOM the thing
that is changed.

---

# Re-render For Every Change

???

- A normal React pattern is just to refresh the views every time.
So re-render the views with new input and cause different output.
As mentioned; the output is diffed against the in-memory DOM.

---

```js
var Name = React.createClass({
  render: function () {
    return <h1>{this.props.name}</h1>;
  }
});

React.render(<Greeting name="Janet van Dyne" />, document.body);

// No actual DOM operations:
React.render(<Greeting name="Janet van Dyne" />, document.body);
React.render(<Greeting name="Janet van Dyne" />, document.body);

// Will change
React.render(<Greeting name="Wasp" />, document.body);
```

---

# Heads Up: Might Create Increased Work For the GC
## Can create a lot of objects that should be thrown away by the GC

---

## Assignments

 - Render two times and see that only the second will be visible.
 - Render twice to update view using setTimeout.
 - Render a clock using setInterval
 - Advanced: Create a list of components, and re-render the tree.

---

???

Setup:
- react component state change causes re-render
- state gets out of hand

- opens many new posibilities
- can still fuck things up

- to recreate the mental model from html
- borrow concepts from functional programming
- makes reasoning about or user intercaes easier
- easier to make less error prone system

---

# functional paradigm

## the mental model

???

- why strive for principles of functional programming?
- easier mental model
- easier to write
- modular programs
- decompose problems into parts

???

- in terms of functional views, as a result, when you find a bug, just dig into the component and _know_ that this is where all

---

# pure functions / referential transparency

## pure functions don't have side effects

```js
var square = function (x) {
  return x * x;
}
```

## "An expresssion is referentially transparent if it can be replaced with its value without changing the behavior of the program."

```js
var x = 2;
var y = x + 1;
var z = x + y; // var z = 3;
```

???

- Property of parts of computer programs.

- Given the same input, the program has the same effects and outputs
- write code that functions that have predictable output, given some input
- side effect free, dont depent on global state
- makes code easier to test

- For programs to be interesting we actually need state and side effects!
- TODO remove? Common examples include the dom, ajax communcation, logging etc.

---

# higher order functions

## Primary building blocks

???

- The glue.

- Functions as values
- Functions can take functions as arguments
- Functions can return functions

---

# Functions that return functions

```js
var adder = function (add) {
  return function (x) {
    return add + x;
  };
};
var add2 = adder(2);
add2(4); // 6
```

???

- function that creates other functions
- the inner function is said to close over `add`
- available after the outer function has returned
- we create a function that always return add2

---

# Function that takes another function as an argument

## From one representation to another

```js
var list = [1, 2, 3];
var square = function (n) {
  return n * n;
};
it('squares numbers', function () {
  list.map(square).should.eql([1, 4, 9])
});
```

???

- like a physical map, go from one place to another
- maps one representation into another
- transforms the dataset into another

---

# Function that takes another function as an argument

## Filters out items of list

```js
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var isFizzOrBuzz = function (n) {
  return n % 5 == 0 || n % 3 == 0;
};
it('keeps fizzbuzz numbers', function () {
  numbers.filter(isFizzOrBuzz).should.eql([3, 5, 6, 9, 10])
});
```

---

# Function that takes another function as an argument

## Reduces items of a list into an accumulator

```js
var numbers = [1, 2, 3, 4, 5];
var multiply = function (acc, n) {
  return acc * n;
}
it('multiplies numbers', function () {
  numbers.reduce(multiply, 1).should.equal(120);
});
```

---

# Data transformation

```js
var episodes = [
  { name: "Cartman Gets an Anal Probe" },
  { name: "Weight Gain 4000" },
  { name: "Volcano" },
  { name: "Big Gay Al's Big Gay Boat Ride" },
  { name: "An Elephant Makes Love to a Pig" },
  { name: "Death" },
  { name: "Pinkeye" }
];

function asName (obj) {
  return obj.name;
}

function nth (list, i) {
  return list[i];
}

it('maps episodes => name', function () {
  nth(episodes.map(asName), 0).should.equal("Cartman Gets an Anal Probe");
  nth(episodes.map(asName), 1).should.equal("Weight Gain 4000");
});
```

???

- all of these are examples of higher order functions
- you pass functions that are used to perform operations on data
- keep their result

- operate on lists
- what programming is about, chrunching data, transforming data from one representation to another

- interesting properties: pure functions, no side effects, immutable structures
- why pure/immutable? others cannot change what is your starting point/basis

---

# assignment

## write a recursive function that sums the numbers of a list

???

- While some operations e.g. map, filter, reduce return new lists, the content of these lists may well be references to objects you started out with
- need to be aware
- not everything is immutable in js as of today

---

# Immutable data

---

# Object.freeze(someObject);

???

- not everything is immutable in js
- easy to loose track of modifications
- what can we do about it?

- Object.freeze() makes it immutable
- "Can't add property <property>, object is not extensible""
- not efficient
- cant update an without copying all values to a new object

- how can we copy it?
- can we copy everything all the time?
- the two are almost exaclty the same - doesnt this use twice the space?

---

# clojure

```js
(def user {:firstname "torgeir"})
(def modified-user (assoc user :lastname "thoresen"))
(= user modified-user) // false
```

???

- some languages have immutable data by default!
- youre forced to keep the output of your operations
- youll never see a void functions

---

# Some things are immutable in most languages!

## string

```js
var name = 'bob';

it('returns new strings', function () {
  var names = name + ' & alice';

  names.should.equal('bob & alice');
  name.should.equal('bob');
});
```

- strings
- primitive datatypes, ints

---

# Js is immutable

## concat()

```js
var list = [1, 2, 3]

var res = list.concat(4) // [1, 2, 3, 4]

list // [1, 2, 3]
```

???

---

# But js is confused

## push()

```js
var list = [1, 2, 3]

list.push(4) // 4

list // [1, 2, 3, 4]
```

???

- push, mutating => why?
- you push 4, you get 4 back - yes, i know already, thanks

---

# immutable data

## alternatives for js

- [ki](http://ki-lang.org)
- [mori](https://github.com/swannodette/mori)
- [clojurescript](http://clojure.org/clojurescript)

???

- there are alternatives for js
- and some of these are awesome
- by super smart people
- but no one is really javascript idiomatic

---

# immutable.js

## facebook

## immutable data strcutures for js

## idiomatic javascript api

???

- smart, nerdy guy at facebook, lee byron
- immutable structures for js

- idiomatic: e.g. treat objects like you otherwise treat objects in javascript
- you have access to the same operations

- because data is immutable, data never changes, data can be shared
- compared to freeze, this implementation can be fast
- sub trees in the larger structure can share information
- persistent data structures
- share structures

TODO bilde av tree, når data endrer seg

---

# Immutable.js

## List - push()

```js
var List = Immutable.List;

var initial = List([1, 2]);
var modified = initial.push(3);

initial // 1, 2
modified // 1, 2, 3
```

---

# Immutable.js

## List - indexOf()

```js
List.of(10, 20, 30, 40, 50).indexOf(30); // 2
```

---

# Immutable.js

## List - remove() (..!)

```js
var initial = List.of(2, 4, 6, 8);
var modified = initial.remove(2);

modified // 2, 4, 8
```

???

- which even js couldnt do..

---

# Immutable.js

## Map - get()

```js
var Map = Immutable.Map;

var map = Map({ "key": "value" });
map.get('key'); // value
```

---

# Immutable.js

## Map - complex keys

```js
var initial = Map().set(List.of(1), 'list-of-one');
initial.get(List.of(1)); // list-of-one
```

---

# Immutable.js

## Map - merge

```js
var first = Map({
  firstname: 'torgeir'
});

var last = Map({
  lastname: 'thoresen'
});

var merged = first.merge(last);

merged.toJS() // { firstname: 'torgeir', lastname: 'thoresen' }
```

---

# Immutable.js

## setIn() / toJS()

```js
var data = Immutable.fromJS({ some: { structure: [1, 2, 3] } });

data.getIn(['some', 'structure']) // Immutable.List([1, 2, 3])

var updated = data.setIn(['some', 'structure', '0'], 42);

updated.toJS(); // { some: { structure: [42, 2, 3 ] } }
data.toJS(); // { some: { structure: [1, 2, 3 ] } }
```

???

gotcha: hva om man setter inn enn VANLIG liste, og ikke en immutable én

---

# Immutable.js

## debugging

```js
updated.inspect(); // "Map { some: Map { structure: List [ 42, 2, 3 ] } }"
```

---

# assignments

## range - create a list with 100 items

## map - map over the numbers to triple every number

## filter - filter out/removes every odd number

## reduce - reduce the numbers to find their sum

## advanced: implement curry() in js

???

---

# curry

```js
var add = function (a, b) { return a + b };
var addCurried = curry(add);
addCurried(2)(6); // 8
```

---

# cursors

???

- another concept of functional programming, similar to functional lenses
- pointers into a data structure
- cursor knows its path in the structure
- get a value out of it,
- or operate on the value

---

# cursors example

```js
var data = Immutable.Map({
  show: 'South Park',
  episodes: [
    { name: "Cartman Gets an Anal Probe" },
    { name: "Weight Gain 400" },
    { name: "Volcano" },
    { name: "Big Gay Al's Big Gay Boat Ride" },
    { name: "An Elephant Makes Love to a Pig" },
  ]
});

var episodes = Cursor.from(data, ['episodes']);

var updatedEpisode = episodes.update([2, 'name'], function (previousName) {
  return previousName + '0';
});
```

???

- can also listen for when the data of a cursor changes
- isolate actions agains separate parts of a structure in an application
- pass a reference on to others
- is much like a view of the data

- in terms of components; this is useful with react components - a component "owns" a piece of state
- which we'll see in a bit, but first some assignments

---

# assignments

## create a cursor

## update a cursor

## show that a cursor is immutable

## show that a cursors callback is called when the cursor is updated

## advanced: create a cursor, and an accompanying function that when called will always return the most recent value of the cursor

???

- we can pass object references as props like we've already seen
- but, what happens if one component mutates the value of a reference?
- another component might have its props changed
- tighlty couples the two components, horizontal coupling
- slippery slope; no longer purity, no longer easily testable, no longer advantages of concurrency

- React 13 will freeze props. Can pass immutable props? yes, but you cant update them.

- since cursors only pass references to the data, and not the data it self
- we can actually swap the pars of the structure that the cursor points to
- when the cursor is updated

- can have ONE structure, outside the components
- no one refers to the structure directly
- prevents horizontal communicaiton
- all components get their data from the top, as input, like arguments

---

# immstruct

## cursors

## updates the structure

## triggers an event

???

- cursors can update a piece in a structure, but returns the new structure
- abstraction to update the structure when a piece changes
- without affecting the other parts of the tree
- listen for changes!
- super easy to re-render on swap

---

# immstruct example

```js
var data = immstruct({ something: 'initial' });

data.on('swap', function (newData, oldData, path) {
  console.log(
    newData.toJS(), // { something: "updated" }
    oldData.toJS(), // { something: "initial" }
    path) // ['something']
});

data.cursor('something').update(function (oldValue) {
  return 'updated';
});
```

???

- make a change
- do something when the structure changes

- resfresh of the data
- isnt that a perfect fit with react - refreshes the view when you rerender
- you can rerender the whole thing

# TODO where?
- react is not a silver bullet
- atom had to move away from it
- to fragmented painting, to much gc on changes

---

# assignments

## recreate the `Hello` component that greets a name - make it re-render on swap, and change the cursor

## create `Counter` component with a button that shows the number of times its been clicked

## create a `Clock` component that re-renders every time the clock updates

???

- Alright! Rerender all the things?
- Is that smart?
- React is clever, and super fast
- But we have unnescessary updates, where data does not change - we re-render everything all the time
- But can we do even better!

---

# React sin shouldComponentUpdate

## A react performance optimization
## Override the function to tell react when a rerender is not nescessary

???

- Tell a component when it needs to render
- Can pass it as a mixin to components

---

# Mixins

```js
React.createClass({
  mixins: []
});
```

---

# shouldComponentUpdate

```js
var AlwaysRerender = {
  shouldComponentUpdate: function () {
    return true;
  }
};

React.createClass({
  mixins: [AlwaysRerender]
});
```

---

# assignments

## create a component that only renders the first time! and never again on new React.render() calls

## write your own mixin that only rerenders when your component is passed odd numbers

???

- and you might be thinking: is not should component update a perfect fit for immutable datastructures?
- instead of deep equaling all arguments to check if theyve changed, and we need to re-render

---

# assignment

## should component that handles immutable structures

---

# omniscient






immutable data har vært vanskelig i js, om gjør det
har kommet flere i det siste, flux gjør det, men mye mer overhead i arkitektur

vi syns det mangler for javascript

# omniscient

react med omniscient should component update

vise omniscient syntaktisk sukker
purity, ref. transparency, rettningslinjer til hvordan du kan lage funksjonelle grensesnitt
lage komponenter som følge disse prinsippene
rene på samme måte som funksjonene er rene
ref. transparent på samme måte som funksjonene er ref. transparent

samme gagn for komponenter som man har av funksjonell kode
opnådd målet med workshoppoen

kan oppnå akkurat det samme med ren react og immutable js
ender med å implementere noe som ligner på immstruct og omniscient
mindre battle tested løsning

kan bruke state - i blant trenger man det - selvfølgelig er det mulig

## assignments
- react with omniscients should component update

endrer fokusområdet til content first
alt en komponent trenger å være er innhold
composability av innhold
render funksjon som er lett å ressonnere over
tar inn argument og jobber bare med det - pure
referencial transparency
higher order components - komponenter tar inn komponenter, returnerer andre komponenter - compsable

isteden for funksjonell programmering på funksjonsnivå
har funksjonell programmering på komponentnivå

## assignments
- pass props
- pass cursors
- effective re-render
- render loop

av og til trenger man ekstra funksjonalitet
lagt opp til at den er enkel på å dele via mixins (traits)
legge funksjonene utenfor komponentene

## assignments

- legge til én mixin
- legge til flere mixins
- legge til react life cycle mixins (alle er garantert til å bli utført, hvis det finnes flere)

Assignments:
 - Creating updatable omniscient components (render loop)

Extras:
 - Remote data?

# TODO cursor contrib i playground

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
