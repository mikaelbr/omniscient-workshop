<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle

# Functional UI, Composable Components and Unidirectional immutable data

---

# The Beginning
## Static HTML, No JS

First there was pure, perfect static model: Just rendering in declarative way. Things were easy to understand just by taking a glance. But there were no inputs. Just static texts as values and attributes.

---

# The Need for Dynamic Views
## Using JS to change the DOM

Need for dynamic changes without server change. In time we got Mootools and jQuery. Now we had ways to traverse, update and manipulate the DOM with ease. Didn’t have much models or any good way in the code to represent what state we have in the DOM

---

# The Need for Structural Views
## More Responsibility to JS

As time went and javascript got more and more popular and as we moved to thicker clients and more logic in the browser, we got things as Backbone. We had models and some javascript views, but still driven by massive blob of a side-effect that is the stateful DOM. It’s not necessarily easy to predict the current state of the DOM, even if we have some representation.

---

# The De-tour Through Increased Power of Models
## Hard-linking Models and DOM

We also got things like Knockout, and later Angular, Ember and such. We could bind a model to a view. The problem is, you very rarely have a model which you can bind directly to a view, so you can have view models, or other representations, but then you’d have to either listen for propagating changes and having weird hacks for propagating changes in the object models doing dirty bit checking or some other polling. And you still have this built up state that’s not too easily reproducible or predictable. We still don’t have the same static mental model as in the pure HTML days


---

# Real Power of Programming
## Moving Views All The Way To JS

The next iteration for views is taking the back to a static model and predictable views. Instead of taking the step of moving more JS into the markup, we do the opposite and move views entirely into a representation in a declarative manner of writing composable views, just as with HTML - but with extended functionality. Instead of having a powerful programming language in a less powerful representation language, we move the representation to the programming language.

---

# Building Representation of Views in JS
## Advantages Of Using React and it's Virtual DOM

---

# Static Mental Model Just Like Good Old HTML

Built for changes over time, and between each change it essentially does a refresh, but has a internal representation of the DOM which it's diffed gainst and the actual changes only occurs when the new generated virtual DOM diverges from the old.

---

```js
React.render(
  React.DOM.h1({}, 'Hello, world!'),
  document.body
);
```

Many, or most, of you might have seen React before, but here is an example, in plain old JS.

---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, world!');
  }
});

// Need to create element from class
React.render(React.createElement(Hello), document.body);
```

Or we can make a component of it, which we can re-use in different settings and compose.

---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, ' + this.props.user.name + '!');
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(React.createElement(Hello, myProps), document.body);
```

We can also pass properties to the components. Much like attributes and children of regular HTML, but instead of being restricted to a protocol of only strings, we can pass objects and more advanced constructs.

---

```js
var Hello = React.createClass({
  render: function () {
    return React.DOM.h1({}, 'Hello, ' + this.props.user.name + '!');
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(React.createElement(Hello, myProps), document.body);

// Render again:
myProps.user.name = 'Scott Lang';
React.render(React.createElement(Hello, myProps), document.body);
```

This will update the view, diff against the virtual dom and render the change. We see here a really static mental model. We can see that we, depending on the input, will print "Hello, SOME NAME!".

---

# Syntactic Sugar: JSX

```js
React.render(
  <h1>Hello, world!</h1>,
  document.body);

//=> Translated to
React.render(
  React.createElement('h1', {}, 'Hello, world!'),
  document.body);
```


In React 0.12.0, they changed from rendering components into rendering Elements based on classes. This to move towards ES6 "Classes". This means in vanilla React it can be somewhat verbose syntax for non-JSX, allthough it is still possible. We'll see later in this workshop how we can make working with vanilla JS better.

JSX is a transpile-to-JS language, with a very small transpilation distance.

---

```jsx
var Hello = React.createClass({
  render: function () {
    return <h1>Hello, {this.props.user.name}!</h1>;
  }
});

// Need to create element from class
var myProps = { user: { name: 'Hank Pym' } };
React.render(<Hello user={myProps.user) />, document.body);
```

Previous example with JSX.

---

##  Assignments: Creating Components

Test out the playground: http://omniscientjs.github.io/workshop

Do following assignments
- Part 1: Making Basic Components
- Part 1: Passing Properties

---

# composable components

## Assignments
 - Composing components (children)

---

# virtual DOM

## Assignments

 - Render twice to update view using setTimeout.
 - Render a clock using setInterval
 - Advanced: Some advanced task

---

Setup:
 - react component state change causes re-render
 - state gets out of hand

---

# functional paradigm

---

## referential transparency

"An expresssion is referentially transparent if it can be replaced with its value without changing the behavior of the program."

Given the same input, the program has the same effects and outputs

Side effect free.

`42 + 42 => 84`

```
var global = 42;
...
global + 42 => ???
```

???

- Property of parts of computer programs.
- For programs to be interesting we actually need state and side effects!
- Common examples include the dom, ajax communcation, logging etc.

---

## mental model

Strive for principles of functional programming?

- easier mental model
- easier to write
- modular programs
- decompose problems into parts

---

## higher order functions

The glue.

Primary building block of functional programming.

- Functions as values
- Functions can take functions as arguments
- Functions can return functions

---

```
var adder = function (add) {
  return function (x) {
    return add + x;
  };
};
var add2 = adder(2);
add2(4); // 6
```
[run](http://omniscientjs.github.io/playground/#var%20adder%20%3D%20function%20(add)%20%7B%0A%20%20return%20function%20(x)%20%7B%0A%20%20%20%20return%20add%20%2B%20x%3B%0A%20%20%7D%3B%0A%7D%3B%0Avar%20add2%20%3D%20adder(2)%3B%0Ait('adds%202'%2C%20()%20%3D%3E%20add2(4).should.equal(6))%3B)

---

```
var list = [1, 2, 3];
var square = function (n) {
  return n * n;
};
it('squares numbers', function () {
  list.map(square).should.eql([1, 4, 9])
});
```
[run](http://omniscientjs.github.io/playground/#var%20list%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Avar%20square%20%3D%20function%20(n)%20%7B%0A%20%20return%20n%20*%20n%3B%0A%7D%3B%0Ait('squares%20numbers'%2C%20function%20()%20%7B%0A%20%20list.map(square).should.eql(%5B1%2C%204%2C%209%5D)%0A%7D)%3B)

---

```
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var isFizzOrBuzz = function (n) {
  /*solution return n % 5 == 0 || n % 3 == 0;*/
};
it('keeps fizzbuzz numbers', function () {
  numbers.filter(isFizzOrBuzz).should.eql([3, 5, 6, 9, 10])
});
```
[run](http://omniscientjs.github.io/playground/#var%20numbers%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%2C%206%2C%207%2C%208%2C%209%2C%2010%5D%3B%0Avar%20isFizzOrBuzz%20%3D%20function%20(n)%20%7B%0A%20%20return%20n%20%25%205%20%3D%3D%200%20%7C%7C%20n%20%25%203%20%3D%3D%200%3B%0A%7D%3B%0Ait('keeps%20fizzbuzz%20numbers'%2C%20function%20()%20%7B%0A%20%20numbers.filter(isFizzOrBuzz).should.eql(%5B3%2C%205%2C%206%2C%209%2C%2010%5D)%0A%7D)%3B)

---

```
var numbers = [1, 2, 3, 4, 5];
var multiply = function (acc, n) {
  return acc * n;
}
it('multiplies numbers', function () {
  numbers.reduce(multiply, 1).should.equal(120);
});
```
[run](http://omniscientjs.github.io/playground/#var%20numbers%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0Avar%20multiply%20%3D%20function%20(acc%2C%20n)%20%7B%0A%20%20return%20acc%20*%20n%3B%0A%7D%0Ait('multiplies%20numbers'%2C%20function%20()%20%7B%0A%20%20numbers.reduce(multiply%2C%201).should.equal(120)%3B%0A%7D)%3B)

---

```
var episodes = [
  { name: "Cartman Gets an Anal Probe" },
  { name: "Weight Gain 4000" },
  { name: "Volcano" },
  { name: "Big Gay Al's Big Gay Boat Ride" },
  { name: "An Elephant Makes Love to a Pig" },
  { name: "Death" },
  { name: "Pinkeye" },
  { name: "Starvin' Marvin" },
  { name: "Mr. Hankey, the Christmas Poo" },
  { name: "Damien" },
  { name: "Tom's Rhinoplasty" },
  { name: "Mecha-Streisand" },
  { name: "Cartman's Mom Is a Dirty Slut" }];

function asName (obj) {
  return obj.name;
}

it('maps episodes => name', function () {
  episodes.map(asName)[0].should.equal("Cartman Gets an Anal Probe");
  episodes.map(asName)[1].should.equal("Weight Gain 4000");
});
```
[run](http://omniscientjs.github.io/playground/#var%20episodes%20%3D%20%5B%0A%20%20%7B%20name%3A%20%22Cartman%20Gets%20an%20Anal%20Probe%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Weight%20Gain%204000%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Volcano%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Big%20Gay%20Al's%20Big%20Gay%20Boat%20Ride%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22An%20Elephant%20Makes%20Love%20to%20a%20Pig%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Death%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Pinkeye%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Starvin'%20Marvin%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Mr.%20Hankey%2C%20the%20Christmas%20Poo%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Damien%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Tom's%20Rhinoplasty%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Mecha-Streisand%22%20%7D%2C%0A%20%20%7B%20name%3A%20%22Cartman's%20Mom%20Is%20a%20Dirty%20Slut%22%20%7D%5D%3B%0A%0Afunction%20asName%20(obj)%20%7B%0A%20%20return%20obj.name%3B%0A%7D%0A%0Ait('maps%20episodes%20%3D%3E%20name'%2C%20function%20()%20%7B%0A%20%20episodes.map(asName)%5B0%5D.should.equal(%22Cartman%20Gets%20an%20Anal%20Probe%22)%3B%0A%20%20episodes.map(asName)%5B1%5D.should.equal(%22Weight%20Gain%204000%22)%3B%0A%7D)%3B)

---

```
var name = 'bob';

it('returns new strings', function () {
  var names = name + ' & alice';

  names.should.equal('bob & alice');
  name.should.equal('bob');
});
```

---

# immutability

Note that while operations like map, filter, reduce etc. return new lists,
the content of these lists may well be the same object references you
started out with.

???

- but not everything is immutable

---

- Object.freeze()

???

- not everything is immutable, easy to loose track of modifications
- what about when we want to use it again?
- we can copy it?
- how?
- can we copy everything all the time?
- the two are almost exaclty the same - doesnt this use twice the space?

---

clojure

```
(def user {:firstname "torgeir"})
(def modified-user (assoc user :lastname "thoresen"))
(= user modified-user) // false
```

---

# js alternatives

- ki
- mori
- clojurescript

---

## immutable.js

- immutable data strcutures for js
- idiomatic javascript api
- persistent data structures

???

- smart, nerdy guy at facebook, lee byron
- immutable structures for js
- share structures
- because data is immutable, data never changes, data can be shared
- sub trees in the larger structure can share information

---

### assignments

```
var List = Immutable.List;

var initial = List([1, 2]);
var modified = initial.push(3);

initial // 1, 2
modified // 1, 2, 3

```

---

```
var initial = List.of(2, 4, 6, 8);
var modified = initial.remove(2);
modified // 2, 4, 8
```

---

```
List.of(10, 20, 30, 40, 50).indexOf(30); // 2
```

---

```
var Map = Immutable.Map;

var map = Map({ "key": "value" });
map.get('key'); // value
```

---

```
var initial = Map().set(List.of(1), 'list-of-one');
initial.get(List.of(1)); // list-of-one
```

---

```
var first = Map({
  firstname: 'torgeir'
});

var last = Map({
  lastname: 'thoresen'
});

var merged = first.merge(last);

merged.toJS() // { firstname: 'torgeir', lastname: 'thoresen' }
```

---

```
var data = Immutable.fromJS({ some: { structure: [1, 2, 3] } });

data.getIn(['some', 'structure']) // Immutable.List([1, 2, 3])

var updated = data.setIn(['some', 'structure', '0'], 42);

updated.toJS(); // { some: { structure: [42, 2, 3 ] } }
data.toJS(); // { some: { structure: [1, 2, 3 ] } }
```

---

debugging

```
updated.inspect(); // "Map { some: Map { structure: List [ 42, 2, 3 ] } }"
```

---

### assignments

- range - create a list with 100 items
- map - map over the numbers to double every number
- filter - filter out every odd numbers
- reduce - reduce the numbers to find their sum

---

## cursors


???

- similar to functional lenses
- pointers into a data structure
- pass a reference on to others
- knows its path in the structure
- listen for updates

### assignments

---

## Immstruct

cursors can update a piece in a structure, but returns the new structure

abstraction to update the structure when a piece changes

without affecting the other parts of the tree

listen for changes - swap

super easy to re-render on swap

---

### assignments

```
var Counter  = React.createClass({

  render: function () {

    var counter = this.props.counter;
    var inc = function (e) {
      counter.update(function (v) {
        return v + 1;
      });
    }

    return <button onClick={inc}>{counter.deref()}</button>;
  }
});


var data = immstruct({ counter: 0 });

var render = function () {
  React.render(<Counter counter={data.cursor('counter')} />, el);
};

data.on('swap', function () {
  render();
});

render();
```

???

- Is that smart?
- React is clever, and super fast
- But can we do even better than with plain react

---

# React sin shouldComponentUpdate

- A react performance optimization
- Override the function to tell react when a rerender is not nescessary
- given the current props, the rendered result will not change

## assignments

write your own mixin that only rerenders when your component is passed odd numbers

```
var OnlyShowOddNumbers = {
  shouldComponentUpdate: function (nextProps) {
    return nextProps.number % 1 == 0;
  }
};

var OddNumbers = React.createClass({
  mixins: [OnlyShowOddNumbers],
  render: function () {
    return <span>{this.props.number}</span>;
  }
});

function render (n) {
  React.render(OddNumbers({ number: n }), el);
}

var i = 0;
setInterval(function () {
  render(i++)
}, 1000);
```

- so, we want to render all the time - its easy right
- here's how we can prevent it
- wont this make a perfect fit for immutable datastructures?
- in stead of deep equaling all arguments to check if theyve changed, and we need to re-render
- YES

## assignments

todo show this?

fint for små komponenter
hva når datastrukturer blir store
må alle komponenetene vite om hele strukturen
kan sende referansene til hvor du finner data - cursors

immutable data har vært vanskelig i js, om gjør det
har kommet flere i det siste, flux gjør det, men mye mer overhead i arkitektur

vi syns det mangler for javascript

# omniscient

syntaktisk sukker
rettningslinjer til hvordan du kan lage funksjonelle grensesnitt
hjelper deg å følge disse

kan oppnå akkurat det samme med ren react og immutable js
ender med å implementere noe som ligner på immstruct og omniscient
mindre battle tested løsning

kan bruke state - i blant trenger man det - selvfølgelig er det mulig

## assignments
- react with omniscients should component update

endrer fokusområdet til content first
alt en komponent trenger å være er innhold
composability
render funksjon som er lett å ressonnere over
tar inn argument og jobber bare med det
referencial transparency
higher order components

## assignments
- pass props
- pass cursors
- effective re-render
- render loop

av og til trenger man ekstra funksjonalitet
lagt opp til at den er enkel på å dele via mixins (traits)
legge funksjonene utenfor komponentene

## assignments

- legge til én mixin
- legge til flere mixins
- legge til react life cycle mixins (alle er garantert til å bli utført, hvis det finnes flere)

Assignments:
 - Creating updatable omniscient components (render loop)

Extras:
 - Remote data?

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>

